import { z } from 'zod';
import { EnvironmentError, InputError, InputErrors, ResultError, } from './errors.js';
import { schemaError, toErrorWithMessage } from './errors.js';
import { isListOfSuccess, formatSchemaErrors, mergeObjects } from './utils.js';
function makeDomainFunction(inputSchema, environmentSchema) {
    return function (handler) {
        return async function (input, environment = {}) {
            const envResult = await (environmentSchema ?? z.object({})).safeParseAsync(environment);
            const result = await (inputSchema ?? z.undefined()).safeParseAsync(input);
            try {
                if (result.success === true && envResult.success === true) {
                    return {
                        success: true,
                        data: await handler(result.data, envResult.data),
                        errors: [],
                        inputErrors: [],
                        environmentErrors: [],
                    };
                }
            }
            catch (error) {
                if (error instanceof InputError) {
                    return {
                        success: false,
                        errors: [],
                        environmentErrors: [],
                        inputErrors: [schemaError(error.message, error.path)],
                    };
                }
                if (error instanceof EnvironmentError) {
                    return {
                        success: false,
                        errors: [],
                        environmentErrors: [schemaError(error.message, error.path)],
                        inputErrors: [],
                    };
                }
                if (error instanceof InputErrors) {
                    return {
                        success: false,
                        errors: [],
                        environmentErrors: [],
                        inputErrors: error.errors.map((e) => schemaError(e.message, e.path)),
                    };
                }
                if (error instanceof ResultError)
                    return error.result;
                return {
                    success: false,
                    errors: [toErrorWithMessage(error)],
                    inputErrors: [],
                    environmentErrors: [],
                };
            }
            return {
                success: false,
                errors: [],
                inputErrors: result.success
                    ? []
                    : formatSchemaErrors(result.error.issues),
                environmentErrors: envResult.success
                    ? []
                    : formatSchemaErrors(envResult.error.issues),
            };
        };
    };
}
function all(...fns) {
    return async (input, environment) => {
        const results = await Promise.all(fns.map((fn) => fn(input, environment)));
        if (!isListOfSuccess(results)) {
            return {
                success: false,
                errors: results.map(({ errors }) => errors).flat(),
                inputErrors: results.map(({ inputErrors }) => inputErrors).flat(),
                environmentErrors: results
                    .map(({ environmentErrors }) => environmentErrors)
                    .flat(),
            };
        }
        return {
            success: true,
            data: results.map(({ data }) => data),
            inputErrors: [],
            environmentErrors: [],
            errors: [],
        };
    };
}
function first(...fns) {
    return async (input, environment) => {
        const results = await Promise.all(fns.map((fn) => fn(input, environment)));
        const result = results.find((r) => r.success);
        if (result) {
            return {
                success: true,
                data: result.data,
                inputErrors: [],
                environmentErrors: [],
                errors: [],
            };
        }
        return {
            success: false,
            errors: results.map(({ errors }) => errors).flat(),
            inputErrors: results.map(({ inputErrors }) => inputErrors).flat(),
            environmentErrors: results
                .map(({ environmentErrors }) => environmentErrors)
                .flat(),
        };
    };
}
function merge(...fns) {
    return async (input, environment) => {
        const results = await Promise.all(fns.map((fn) => fn(input, environment)));
        if (!isListOfSuccess(results)) {
            return {
                success: false,
                errors: results.map(({ errors }) => errors).flat(),
                inputErrors: results.map(({ inputErrors }) => inputErrors).flat(),
                environmentErrors: results
                    .map(({ environmentErrors }) => environmentErrors)
                    .flat(),
            };
        }
        const collectedResults = results.map(({ data }) => data);
        const resultSchema = z.array(z.object({}));
        if (!resultSchema.safeParse(collectedResults).success) {
            return {
                success: false,
                errors: [
                    { message: 'Invalid data format returned from some domainFunction' },
                ],
                inputErrors: [],
                environmentErrors: [],
            };
        }
        return {
            success: true,
            data: mergeObjects(collectedResults),
            inputErrors: [],
            environmentErrors: [],
            errors: [],
        };
    };
}
function pipe(...fns) {
    const [head, ...tail] = fns;
    return ((input, environment) => {
        return tail.reduce(async (memo, fn) => {
            const resolved = await memo;
            if (resolved.success) {
                return fn(resolved.data, environment);
            }
            else {
                return memo;
            }
        }, head(input, environment));
    });
}
function sequence(...fns) {
    return async function (input, environment) {
        const results = [];
        let currResult;
        for await (const fn of fns) {
            const result = await fn(currResult?.success ? currResult.data : input, environment);
            if (!result.success)
                return result;
            currResult = result;
            results.push(result.data);
        }
        return {
            success: true,
            data: results,
            inputErrors: [],
            environmentErrors: [],
            errors: [],
        };
    };
}
function map(dfn, mapper) {
    return async (input, environment) => {
        const result = await dfn(input, environment);
        if (!result.success)
            return result;
        try {
            return {
                success: true,
                data: mapper(result.data),
                errors: [],
                inputErrors: [],
                environmentErrors: [],
            };
        }
        catch (error) {
            const errors = [toErrorWithMessage(error)];
            return {
                success: false,
                errors,
                inputErrors: [],
                environmentErrors: [],
            };
        }
    };
}
function fromSuccess(df) {
    return async function (...args) {
        const result = await df(...args);
        if (!result.success)
            throw new ResultError(result);
        return result.data;
    };
}
function mapError(dfn, mapper) {
    return async (input, environment) => {
        const result = await dfn(input, environment);
        if (result.success)
            return result;
        try {
            return { ...mapper(result), success: false };
        }
        catch (error) {
            const errors = [toErrorWithMessage(error)];
            return {
                success: false,
                errors,
                inputErrors: [],
                environmentErrors: [],
            };
        }
    };
}
function trace(traceFn) {
    return (fn) => async (input, environment) => {
        const result = await fn(input, environment);
        traceFn({ input, environment, result });
        return result;
    };
}
export { all, first, fromSuccess, makeDomainFunction, map, mapError, merge, pipe, sequence, trace, };
