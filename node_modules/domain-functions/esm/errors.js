function isErrorWithMessage(error) {
    return (typeof error === 'object' &&
        error !== null &&
        'message' in error &&
        typeof error.message === 'string');
}
function toErrorWithMessage(maybeError) {
    const message = isErrorWithMessage(maybeError)
        ? maybeError.message
        : String(maybeError);
    return {
        message,
        exception: maybeError,
    };
}
function schemaError(message, path) {
    return { message, path: path.split('.') };
}
function errorMessagesFor(errors, name) {
    return errors
        .filter(({ path }) => path.join('.') === name)
        .map(({ message }) => message);
}
function errorMessagesForSchema(errors, _schema) {
    const nest = ({ path, messages }, root) => {
        const [head, ...tail] = path;
        root[head] =
            tail.length === 0
                ? messages
                : nest({ path: tail, messages }, root[head] ?? {});
        return root;
    };
    const compareStringArrays = (a) => (b) => JSON.stringify(a) === JSON.stringify(b);
    const toErrorObject = (errors) => errors.map(({ path, message }) => ({
        path,
        messages: [message],
    }));
    const unifyPaths = (errors) => toErrorObject(errors).reduce((memo, error) => {
        const comparePath = compareStringArrays(error.path);
        const mergeErrorMessages = ({ path, messages }) => comparePath(path)
            ? { path, messages: [...messages, ...error.messages] }
            : { path, messages };
        const existingPath = memo.find(({ path }) => comparePath(path));
        return existingPath ? memo.map(mergeErrorMessages) : [...memo, error];
    }, []);
    const errorTree = unifyPaths(errors).reduce((memo, schemaError) => {
        const errorBranch = nest(schemaError, memo);
        return { ...memo, ...errorBranch };
    }, {});
    return errorTree;
}
class InputError extends Error {
    constructor(message, path) {
        super(message);
        Object.defineProperty(this, "path", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'InputError';
        this.path = path;
    }
}
class InputErrors extends Error {
    constructor(errors) {
        super(`${errors.length} errors`);
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.errors = errors;
    }
}
class EnvironmentError extends Error {
    constructor(message, path) {
        super(message);
        Object.defineProperty(this, "path", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'EnvironmentError';
        this.path = path;
    }
}
class ResultError extends Error {
    constructor(result) {
        super('ResultError');
        Object.defineProperty(this, "result", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'ResultError';
        this.result = {
            errors: [],
            inputErrors: [],
            environmentErrors: [],
            ...result,
            success: false,
        };
    }
}
export { errorMessagesFor, errorMessagesForSchema, schemaError, toErrorWithMessage, InputError, EnvironmentError, InputErrors, ResultError, };
