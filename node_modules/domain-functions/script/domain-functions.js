"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trace = exports.sequence = exports.pipe = exports.merge = exports.mapError = exports.map = exports.makeDomainFunction = exports.fromSuccess = exports.first = exports.all = void 0;
const zod_1 = require("zod");
const errors_js_1 = require("./errors.js");
const errors_js_2 = require("./errors.js");
const utils_js_1 = require("./utils.js");
function makeDomainFunction(inputSchema, environmentSchema) {
    return function (handler) {
        return async function (input, environment = {}) {
            const envResult = await (environmentSchema ?? zod_1.z.object({})).safeParseAsync(environment);
            const result = await (inputSchema ?? zod_1.z.undefined()).safeParseAsync(input);
            try {
                if (result.success === true && envResult.success === true) {
                    return {
                        success: true,
                        data: await handler(result.data, envResult.data),
                        errors: [],
                        inputErrors: [],
                        environmentErrors: [],
                    };
                }
            }
            catch (error) {
                if (error instanceof errors_js_1.InputError) {
                    return {
                        success: false,
                        errors: [],
                        environmentErrors: [],
                        inputErrors: [(0, errors_js_2.schemaError)(error.message, error.path)],
                    };
                }
                if (error instanceof errors_js_1.EnvironmentError) {
                    return {
                        success: false,
                        errors: [],
                        environmentErrors: [(0, errors_js_2.schemaError)(error.message, error.path)],
                        inputErrors: [],
                    };
                }
                if (error instanceof errors_js_1.InputErrors) {
                    return {
                        success: false,
                        errors: [],
                        environmentErrors: [],
                        inputErrors: error.errors.map((e) => (0, errors_js_2.schemaError)(e.message, e.path)),
                    };
                }
                if (error instanceof errors_js_1.ResultError)
                    return error.result;
                return {
                    success: false,
                    errors: [(0, errors_js_2.toErrorWithMessage)(error)],
                    inputErrors: [],
                    environmentErrors: [],
                };
            }
            return {
                success: false,
                errors: [],
                inputErrors: result.success
                    ? []
                    : (0, utils_js_1.formatSchemaErrors)(result.error.issues),
                environmentErrors: envResult.success
                    ? []
                    : (0, utils_js_1.formatSchemaErrors)(envResult.error.issues),
            };
        };
    };
}
exports.makeDomainFunction = makeDomainFunction;
function all(...fns) {
    return async (input, environment) => {
        const results = await Promise.all(fns.map((fn) => fn(input, environment)));
        if (!(0, utils_js_1.isListOfSuccess)(results)) {
            return {
                success: false,
                errors: results.map(({ errors }) => errors).flat(),
                inputErrors: results.map(({ inputErrors }) => inputErrors).flat(),
                environmentErrors: results
                    .map(({ environmentErrors }) => environmentErrors)
                    .flat(),
            };
        }
        return {
            success: true,
            data: results.map(({ data }) => data),
            inputErrors: [],
            environmentErrors: [],
            errors: [],
        };
    };
}
exports.all = all;
function first(...fns) {
    return async (input, environment) => {
        const results = await Promise.all(fns.map((fn) => fn(input, environment)));
        const result = results.find((r) => r.success);
        if (result) {
            return {
                success: true,
                data: result.data,
                inputErrors: [],
                environmentErrors: [],
                errors: [],
            };
        }
        return {
            success: false,
            errors: results.map(({ errors }) => errors).flat(),
            inputErrors: results.map(({ inputErrors }) => inputErrors).flat(),
            environmentErrors: results
                .map(({ environmentErrors }) => environmentErrors)
                .flat(),
        };
    };
}
exports.first = first;
function merge(...fns) {
    return async (input, environment) => {
        const results = await Promise.all(fns.map((fn) => fn(input, environment)));
        if (!(0, utils_js_1.isListOfSuccess)(results)) {
            return {
                success: false,
                errors: results.map(({ errors }) => errors).flat(),
                inputErrors: results.map(({ inputErrors }) => inputErrors).flat(),
                environmentErrors: results
                    .map(({ environmentErrors }) => environmentErrors)
                    .flat(),
            };
        }
        const collectedResults = results.map(({ data }) => data);
        const resultSchema = zod_1.z.array(zod_1.z.object({}));
        if (!resultSchema.safeParse(collectedResults).success) {
            return {
                success: false,
                errors: [
                    { message: 'Invalid data format returned from some domainFunction' },
                ],
                inputErrors: [],
                environmentErrors: [],
            };
        }
        return {
            success: true,
            data: (0, utils_js_1.mergeObjects)(collectedResults),
            inputErrors: [],
            environmentErrors: [],
            errors: [],
        };
    };
}
exports.merge = merge;
function pipe(...fns) {
    const [head, ...tail] = fns;
    return ((input, environment) => {
        return tail.reduce(async (memo, fn) => {
            const resolved = await memo;
            if (resolved.success) {
                return fn(resolved.data, environment);
            }
            else {
                return memo;
            }
        }, head(input, environment));
    });
}
exports.pipe = pipe;
function sequence(...fns) {
    return async function (input, environment) {
        const results = [];
        let currResult;
        for await (const fn of fns) {
            const result = await fn(currResult?.success ? currResult.data : input, environment);
            if (!result.success)
                return result;
            currResult = result;
            results.push(result.data);
        }
        return {
            success: true,
            data: results,
            inputErrors: [],
            environmentErrors: [],
            errors: [],
        };
    };
}
exports.sequence = sequence;
function map(dfn, mapper) {
    return async (input, environment) => {
        const result = await dfn(input, environment);
        if (!result.success)
            return result;
        try {
            return {
                success: true,
                data: mapper(result.data),
                errors: [],
                inputErrors: [],
                environmentErrors: [],
            };
        }
        catch (error) {
            const errors = [(0, errors_js_2.toErrorWithMessage)(error)];
            return {
                success: false,
                errors,
                inputErrors: [],
                environmentErrors: [],
            };
        }
    };
}
exports.map = map;
function fromSuccess(df) {
    return async function (...args) {
        const result = await df(...args);
        if (!result.success)
            throw new errors_js_1.ResultError(result);
        return result.data;
    };
}
exports.fromSuccess = fromSuccess;
function mapError(dfn, mapper) {
    return async (input, environment) => {
        const result = await dfn(input, environment);
        if (result.success)
            return result;
        try {
            return { ...mapper(result), success: false };
        }
        catch (error) {
            const errors = [(0, errors_js_2.toErrorWithMessage)(error)];
            return {
                success: false,
                errors,
                inputErrors: [],
                environmentErrors: [],
            };
        }
    };
}
exports.mapError = mapError;
function trace(traceFn) {
    return (fn) => async (input, environment) => {
        const result = await fn(input, environment);
        traceFn({ input, environment, result });
        return result;
    };
}
exports.trace = trace;
