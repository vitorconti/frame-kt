declare type ErrorWithMessage = {
    message: string;
    exception?: unknown;
};
declare type SuccessResult<T = void> = {
    success: true;
    data: T;
    errors: [];
    inputErrors: [];
    environmentErrors: [];
};
declare type ErrorResult = {
    success: false;
    errors: ErrorWithMessage[];
    inputErrors: SchemaError[];
    environmentErrors: SchemaError[];
};
declare type SchemaError = {
    path: string[];
    message: string;
};
declare type ErrorData = Omit<ErrorResult, 'success'>;
declare type Result<T = void> = SuccessResult<T> | ErrorResult;
declare type DomainFunction<Output = unknown> = {
    (input?: unknown, environment?: unknown): Promise<Result<Output>>;
};
declare type UnpackResult<F extends DomainFunction> = Awaited<ReturnType<F>>;
declare type UnpackSuccess<F extends DomainFunction> = Extract<UnpackResult<F>, {
    success: true;
}>;
declare type UnpackData<F extends DomainFunction> = UnpackSuccess<F>['data'];
declare type UnpackAll<List, output extends unknown[] = []> = List extends [
    DomainFunction<infer first>,
    ...infer rest
] ? UnpackAll<rest, [...output, first]> : output;
declare type MergeObjs<Objs extends unknown[], output = {}> = Objs extends [
    infer first,
    ...infer rest
] ? MergeObjs<rest, output & first> : output;
declare type TupleToUnion<T extends unknown[]> = T[number];
declare type Last<T extends readonly unknown[]> = T extends [...infer _I, infer L] ? L : never;
declare type AtLeastOne<T, U = {
    [K in keyof T]: Pick<T, K>;
}> = Partial<T> & U[keyof U];
export type { AtLeastOne, DomainFunction, ErrorData, ErrorResult, ErrorWithMessage, Last, MergeObjs, Result, SchemaError, SuccessResult, TupleToUnion, UnpackAll, UnpackData, UnpackResult, UnpackSuccess, };
