import { z } from 'zod';
import type { DomainFunction, ErrorData, MergeObjs, TupleToUnion, UnpackAll, UnpackData, UnpackResult } from './types.js';
import type { Last } from './types.js';
declare function makeDomainFunction<Schema extends z.ZodTypeAny, EnvSchema extends z.ZodTypeAny>(inputSchema?: Schema, environmentSchema?: EnvSchema): <Output>(handler: (input: z.infer<Schema>, environment: z.infer<EnvSchema>) => Promise<Output>) => DomainFunction<Output>;
declare function all<Fns extends DomainFunction[]>(...fns: Fns): DomainFunction<UnpackAll<Fns>>;
declare function first<Fns extends DomainFunction[]>(...fns: Fns): DomainFunction<TupleToUnion<UnpackAll<Fns>>>;
declare function merge<Fns extends DomainFunction[]>(...fns: Fns): DomainFunction<MergeObjs<UnpackAll<Fns>>>;
declare function pipe<T extends DomainFunction[]>(...fns: T): Last<T>;
declare function sequence<Fns extends DomainFunction[]>(...fns: Fns): DomainFunction<UnpackAll<Fns>>;
declare function map<O, R>(dfn: DomainFunction<O>, mapper: (element: O) => R): DomainFunction<R>;
declare function fromSuccess<T extends DomainFunction>(df: T): (...args: Parameters<DomainFunction>) => Promise<UnpackData<T>>;
declare function mapError<O>(dfn: DomainFunction<O>, mapper: (element: ErrorData) => ErrorData): DomainFunction<O>;
declare type TraceData<T> = {
    input: unknown;
    environment: unknown;
    result: T;
};
declare function trace<D extends DomainFunction = DomainFunction<unknown>>(traceFn: ({ input, environment, result }: TraceData<UnpackResult<D>>) => void): <T>(fn: DomainFunction<T>) => DomainFunction<T>;
export { all, first, fromSuccess, makeDomainFunction, map, mapError, merge, pipe, sequence, trace, };
