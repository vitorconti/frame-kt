import * as React$1 from 'react';
import { z, SomeZodObject, ZodTypeAny } from 'zod';
import { UseFormRegisterReturn, ValidationMode, UseFormReturn } from 'react-hook-form';
import { DomainFunction } from 'domain-functions';

declare type FormSchema<T extends z.ZodTypeAny = z.SomeZodObject | z.ZodEffects<any>> = z.ZodEffects<T> | z.SomeZodObject;
declare type ObjectFromSchema<T> = T extends z.SomeZodObject ? T : T extends z.ZodEffects<infer R> ? ObjectFromSchema<R> : never;
declare type ComponentOrTagName<ElementType extends keyof JSX.IntrinsicElements> = React.ComponentType<JSX.IntrinsicElements[ElementType]> | string;
declare type KeysOfStrings<T extends object> = {
    [K in keyof T]: T[K] extends string ? K : never;
}[keyof T];

declare type RedirectFunction = (url: string, init?: number | ResponseInit) => Response;
declare type JsonFunction = <Data>(data: Data, init?: number | ResponseInit) => Response;
declare type FormActionFailure<SchemaType> = {
    errors: FormErrors<SchemaType>;
    values: FormValues<SchemaType>;
};
declare type FormValues<SchemaType> = Partial<Record<keyof SchemaType, any>>;
declare type FormErrors<SchemaType> = Partial<Record<keyof SchemaType | '_global', string[]>>;
declare type PerformMutation<SchemaType, D extends unknown> = ({
    success: false;
} & FormActionFailure<SchemaType>) | {
    success: true;
    data: D;
};
declare type Callback = (request: Request) => Promise<Response | void>;
declare type PerformMutationProps<Schema extends FormSchema, D extends unknown> = {
    request: Request;
    schema: Schema;
    mutation: DomainFunction<D>;
    environment?: unknown;
    transformValues?: (values: FormValues<z.infer<Schema>>) => Record<string, unknown>;
};
declare type FormActionProps<Schema extends FormSchema, D extends unknown> = {
    beforeAction?: Callback;
    beforeSuccess?: Callback;
    successPath?: string | ((data: D) => string);
} & PerformMutationProps<Schema, D>;
declare function performMutation<Schema extends FormSchema, D extends unknown>({ request, schema, mutation, environment, transformValues, }: PerformMutationProps<Schema, D>): Promise<PerformMutation<z.infer<Schema>, D>>;
declare function createFormAction({ redirect, json, }: {
    redirect: RedirectFunction;
    json: JsonFunction;
}): <Schema extends FormSchema<z.SomeZodObject | z.ZodEffects<any, any, any>>, D extends unknown>({ request, schema, mutation, environment, transformValues, beforeAction, beforeSuccess, successPath, }: FormActionProps<Schema, D>) => Promise<Response>;

declare type Option = {
    name: string;
} & Required<Pick<React$1.OptionHTMLAttributes<HTMLOptionElement>, 'value'>>;
declare type Children$1<Schema extends SomeZodObject> = (helpers: FieldBaseProps<Schema> & {
    Label: ComponentOrTagName<'label'>;
    SmartInput: React$1.ComponentType<SmartInputProps>;
    Input: React$1.ForwardRefExoticComponent<React$1.PropsWithoutRef<JSX.IntrinsicElements['input']> & React$1.RefAttributes<HTMLInputElement>> | string;
    Multiline: React$1.ForwardRefExoticComponent<React$1.PropsWithoutRef<JSX.IntrinsicElements['textarea']> & React$1.RefAttributes<HTMLTextAreaElement>> | string;
    Select: React$1.ForwardRefExoticComponent<React$1.PropsWithoutRef<JSX.IntrinsicElements['select']> & React$1.RefAttributes<HTMLSelectElement>> | string;
    Checkbox: React$1.ForwardRefExoticComponent<React$1.PropsWithoutRef<JSX.IntrinsicElements['input']> & React$1.RefAttributes<HTMLInputElement>> | string;
    RadioGroup: ComponentOrTagName<'fieldset'>;
    RadioWrapper: ComponentOrTagName<'div'>;
    Radio: React$1.ForwardRefExoticComponent<React$1.PropsWithoutRef<JSX.IntrinsicElements['input']> & React$1.RefAttributes<HTMLInputElement>> | string;
    CheckboxWrapper: ComponentOrTagName<'div'>;
    Errors: ComponentOrTagName<'div'>;
    Error: ComponentOrTagName<'div'>;
    ref: React$1.ForwardedRef<any>;
}) => React$1.ReactNode;
declare type FieldType = 'string' | 'boolean' | 'number' | 'date';
declare type FieldBaseProps<Schema extends SomeZodObject> = Omit<Partial<Field<z.infer<Schema>>>, 'name'> & {
    name: keyof z.infer<Schema>;
    type?: JSX.IntrinsicElements['input']['type'];
    children?: Children$1<Schema>;
};
declare type FieldProps<Schema extends SomeZodObject> = FieldBaseProps<Schema> & Omit<JSX.IntrinsicElements['div'], 'children'>;
declare type FieldComponent<Schema extends SomeZodObject> = React$1.ForwardRefExoticComponent<FieldProps<Schema> & React$1.RefAttributes<any>>;
declare type ComponentMappings = {
    fieldComponent?: ComponentOrTagName<'div'>;
    labelComponent?: ComponentOrTagName<'label'>;
    inputComponent?: React$1.ForwardRefExoticComponent<React$1.PropsWithoutRef<JSX.IntrinsicElements['input']> & React$1.RefAttributes<HTMLInputElement>> | string;
    multilineComponent?: React$1.ForwardRefExoticComponent<React$1.PropsWithoutRef<JSX.IntrinsicElements['textarea']> & React$1.RefAttributes<HTMLTextAreaElement>> | string;
    selectComponent?: React$1.ForwardRefExoticComponent<React$1.PropsWithoutRef<JSX.IntrinsicElements['select']> & React$1.RefAttributes<HTMLSelectElement>> | string;
    checkboxComponent?: React$1.ForwardRefExoticComponent<React$1.PropsWithoutRef<JSX.IntrinsicElements['input']> & React$1.RefAttributes<HTMLInputElement>> | string;
    radioComponent?: React$1.ForwardRefExoticComponent<React$1.PropsWithoutRef<JSX.IntrinsicElements['input']> & React$1.RefAttributes<HTMLInputElement>> | string;
    checkboxWrapperComponent?: ComponentOrTagName<'div'>;
    radioWrapperComponent?: ComponentOrTagName<'div'>;
    radioGroupComponent?: ComponentOrTagName<'fieldset'>;
    fieldErrorsComponent?: ComponentOrTagName<'div'>;
    errorComponent?: ComponentOrTagName<'div'>;
};
declare type SmartInputProps = {
    fieldType?: FieldType;
    type?: React$1.HTMLInputTypeAttribute;
    value?: any;
    autoFocus?: boolean;
    options?: Option[];
    multiline?: boolean;
    radio?: boolean;
    placeholder?: string;
    registerProps?: UseFormRegisterReturn;
    className?: string;
    a11yProps?: Record<`aria-${string}`, string | boolean | undefined>;
};
declare function useField(): Partial<Omit<Field<never>, "name">>;

declare type FormMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';
declare type BaseFormProps = {
    method?: FormMethod;
    onSubmit?: React$1.FormEventHandler<HTMLFormElement>;
    children: React$1.ReactNode;
};
declare type BaseFormPropsWithHTMLAttributes = React$1.FormHTMLAttributes<HTMLFormElement> & BaseFormProps;
declare type FormComponent = React$1.ForwardRefExoticComponent<React$1.PropsWithoutRef<BaseFormProps> & React$1.RefAttributes<HTMLFormElement>>;
declare type Field<SchemaType> = {
    shape: ZodTypeAny;
    fieldType: FieldType;
    name: keyof SchemaType;
    required: boolean;
    dirty: boolean;
    label?: string;
    options?: Option[];
    errors?: string[];
    autoFocus?: boolean;
    value?: any;
    hidden?: boolean;
    multiline?: boolean;
    radio?: boolean;
    placeholder?: string;
};
declare type RenderFieldProps<Schema extends SomeZodObject> = Field<z.infer<Schema>> & {
    Field: FieldComponent<Schema>;
};
declare type RenderField<Schema extends SomeZodObject> = (props: RenderFieldProps<Schema>) => JSX.Element;
declare type Options<SchemaType> = Partial<Record<keyof SchemaType, Option[]>>;
declare type Children<Schema extends SomeZodObject> = (helpers: {
    Field: FieldComponent<Schema>;
    Errors: ComponentOrTagName<'div'>;
    Error: ComponentOrTagName<'div'>;
    Button: ComponentOrTagName<'button'>;
    submit: () => void;
} & UseFormReturn<z.infer<Schema>, any>) => React$1.ReactNode;
declare type Transition = {
    state: 'idle' | 'loading' | 'submitting';
};
declare type OnTransition<Schema extends SomeZodObject> = (helpers: UseFormReturn<z.infer<Schema>, any>) => void;
declare type SubmitFunction = ({ target }: {
    target: any;
}) => void;
declare type FetcherWithComponents = Transition & {
    data: any;
    Form: FormComponent;
    submit: SubmitFunction;
};
declare type FormProps<Schema extends FormSchema> = ComponentMappings & {
    component?: FormComponent;
    fetcher?: FetcherWithComponents;
    mode?: keyof ValidationMode;
    reValidateMode?: keyof Pick<ValidationMode, 'onBlur' | 'onChange' | 'onSubmit'>;
    renderField?: RenderField<ObjectFromSchema<Schema>>;
    globalErrorsComponent?: ComponentOrTagName<'div'>;
    buttonComponent?: ComponentOrTagName<'button'>;
    buttonLabel?: string;
    pendingButtonLabel?: string;
    schema: Schema;
    errors?: FormErrors<z.infer<Schema>>;
    values?: FormValues<z.infer<Schema>>;
    labels?: Partial<Record<keyof z.infer<Schema>, string>>;
    placeholders?: Partial<Record<keyof z.infer<Schema>, string>>;
    options?: Options<z.infer<Schema>>;
    hiddenFields?: Array<keyof z.infer<Schema>>;
    multiline?: Array<keyof z.infer<Schema>>;
    radio?: Array<KeysOfStrings<z.infer<ObjectFromSchema<Schema>>>>;
    autoFocus?: keyof z.infer<Schema>;
    beforeChildren?: React$1.ReactNode;
    onTransition?: OnTransition<ObjectFromSchema<Schema>>;
    /** @deprecated use your custom json/useActionData in createFormAction/createForm instead */
    parseActionData?: (data: any) => any;
    children?: Children<ObjectFromSchema<Schema>>;
} & Omit<BaseFormPropsWithHTMLAttributes, 'children'>;
declare function createForm({ component: DefaultComponent, useNavigation, useSubmit, useActionData, }: {
    component: FormComponent;
    useNavigation: () => Transition;
    useSubmit: () => SubmitFunction;
    useActionData: () => unknown;
}): <Schema extends FormSchema<SomeZodObject | z.ZodEffects<any, any, any>>>({ component, fetcher, mode, reValidateMode, renderField, fieldComponent, globalErrorsComponent: Errors, errorComponent: Error, fieldErrorsComponent, labelComponent, inputComponent, multilineComponent, selectComponent, checkboxComponent, radioComponent, checkboxWrapperComponent, radioGroupComponent, radioWrapperComponent, buttonComponent: Button, buttonLabel: rawButtonLabel, pendingButtonLabel, method, schema, beforeChildren, onTransition, parseActionData, children: childrenFn, labels, placeholders, options, hiddenFields, multiline, radio, autoFocus: autoFocusProp, errors: errorsProp, values: valuesProp, ...props }: FormProps<Schema>) => JSX.Element;

export { Callback, FormActionProps, FormProps, FormSchema, PerformMutation, RenderField, RenderFieldProps, createForm, createFormAction, performMutation, useField };
