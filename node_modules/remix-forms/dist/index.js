"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createForm: () => createForm,
  createFormAction: () => createFormAction,
  performMutation: () => performMutation,
  useField: () => useField
});
module.exports = __toCommonJS(src_exports);

// src/createForm.tsx
var React3 = __toESM(require("react"));

// src/prelude.ts
function objectFromSchema(schema) {
  return "shape" in schema ? schema : objectFromSchema(schema._def.schema);
}
function mapObject(obj, mapFunction) {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => mapFunction(key, value))
  );
}
function parseDate(value) {
  if (!value)
    return value;
  const dateTime = typeof value === "string" ? value : value.toISOString();
  const [date] = dateTime.split("T");
  return date;
}
function browser() {
  return typeof document === "object";
}

// src/createForm.tsx
var import_react_hook_form = require("react-hook-form");
var import_zod = require("@hookform/resolvers/zod");

// src/createField.tsx
var React2 = __toESM(require("react"));

// src/childrenTraversal.ts
var React = __toESM(require("react"));
function mapChildren(children, fn) {
  return React.Children.map(children, (child) => {
    if (!React.isValidElement(child))
      return child;
    const mapped = fn(child);
    if (child.props.children && typeof child.props.children !== "function") {
      const mappedChildren = mapChildren(child.props.children, fn);
      return mapped && React.cloneElement(mapped, { children: mappedChildren });
    }
    return mapped;
  });
}
function findElement(root, predicate) {
  const initialState = null;
  return reduceElements(
    root,
    initialState,
    (previous, current) => {
      if (previous)
        return previous;
      if (predicate(current)) {
        return current;
      }
      return null;
    }
  );
}
function findParent(root, child) {
  return findElement(root, (parentCandidate) => {
    var _a, _b, _c;
    const me = (_c = (_b = (_a = parentCandidate.props) == null ? void 0 : _a.children) == null ? void 0 : _b.find) == null ? void 0 : _c.call(
      _b,
      (ch) => {
        return ch === child;
      }
    );
    return !!me;
  });
}
function reduceElements(children, initialState, reducer) {
  let foldedValue = initialState;
  React.Children.forEach(children, (child) => {
    if (!React.isValidElement(child))
      return;
    foldedValue = reducer(foldedValue, child);
    if (child.props.children && typeof child.props.children !== "function") {
      foldedValue = reduceElements(child.props.children, foldedValue, reducer);
    }
  });
  return foldedValue;
}

// src/shapeInfo.ts
function shapeInfo(shape, optional = false, nullable = false, getDefaultValue, enumValues) {
  if (!shape) {
    return { typeName: null, optional, nullable, getDefaultValue, enumValues };
  }
  const typeName = shape._def.typeName;
  if (typeName === "ZodEffects") {
    return shapeInfo(
      shape._def.schema,
      optional,
      nullable,
      getDefaultValue,
      enumValues
    );
  }
  if (typeName === "ZodOptional") {
    return shapeInfo(
      shape._def.innerType,
      true,
      nullable,
      getDefaultValue,
      enumValues
    );
  }
  if (typeName === "ZodNullable") {
    return shapeInfo(
      shape._def.innerType,
      optional,
      true,
      getDefaultValue,
      enumValues
    );
  }
  if (typeName === "ZodDefault") {
    return shapeInfo(
      shape._def.innerType,
      optional,
      nullable,
      shape._def.defaultValue,
      enumValues
    );
  }
  if (typeName === "ZodEnum") {
    return {
      typeName,
      optional,
      nullable,
      getDefaultValue,
      enumValues: shape._def.values
    };
  }
  return { typeName, optional, nullable, getDefaultValue, enumValues };
}

// src/coercions.ts
function makeCoercion(coercion, emptyValue) {
  return ({
    value,
    optional,
    nullable
  }) => {
    if (value)
      return coercion(value);
    if (nullable)
      return null;
    if (optional)
      return void 0;
    return emptyValue;
  };
}
var coerceString = makeCoercion(String, "");
var coerceNumber = makeCoercion(Number, null);
var coerceBoolean = makeCoercion(Boolean, false);
var coerceDate = makeCoercion((value) => {
  if (typeof value !== "string")
    return null;
  const [year, month, day] = value.split("-").map(Number);
  return new Date(year, month - 1, day);
}, null);
function coerceValue(value, shape) {
  const { typeName, optional, nullable } = shapeInfo(shape);
  if (typeName === "ZodBoolean") {
    return coerceBoolean({ value, optional, nullable });
  }
  if (typeName === "ZodNumber") {
    return coerceNumber({ value, optional, nullable });
  }
  if (typeName === "ZodDate") {
    return coerceDate({ value, optional, nullable });
  }
  if (typeName === "ZodString" || typeName === "ZodEnum") {
    return coerceString({ value, optional, nullable });
  }
  return value;
}

// src/createField.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var types = {
  boolean: "checkbox",
  string: "text",
  number: "text",
  date: "date"
};
function getInputType(type, radio) {
  if (radio)
    return "radio";
  return types[type];
}
var FieldContext = React2.createContext(void 0);
function useField() {
  const context = React2.useContext(FieldContext);
  if (!context)
    throw new Error("useField used outside of field context");
  return context;
}
var makeSelectOption = ({ name, value }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", {
  value,
  children: name
}, String(value));
var makeOptionComponents = (fn, options) => options ? options.map(fn) : void 0;
function createSmartInput({
  inputComponent: Input = "input",
  multilineComponent: Multiline = "textarea",
  selectComponent: Select = "select",
  checkboxComponent: Checkbox = "input",
  labelComponent: Label = "label",
  radioComponent: Radio = "input",
  radioWrapperComponent: RadioWrapper = "div"
}) {
  return ({
    fieldType,
    type,
    value,
    autoFocus,
    options,
    multiline,
    radio,
    placeholder,
    registerProps,
    a11yProps,
    ...props
  }) => {
    if (!registerProps)
      return null;
    const makeRadioOption = (props2, checkedValue) => ({ name: name2, value: value2 }) => {
      const propsWithUniqueId = mapObject(
        props2,
        (key, propValue) => key === "id" ? [key, `${propValue}-${value2}`] : [key, propValue]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(RadioWrapper, {
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Radio, {
            type: "radio",
            value: value2,
            defaultChecked: value2 === checkedValue,
            ...propsWithUniqueId
          }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Label, {
            htmlFor: String(propsWithUniqueId == null ? void 0 : propsWithUniqueId.id),
            children: name2
          })
        ]
      }, String(propsWithUniqueId == null ? void 0 : propsWithUniqueId.id));
    };
    const { name } = registerProps;
    const commonProps = {
      id: name,
      autoFocus,
      ...registerProps,
      ...props
    };
    return fieldType === "boolean" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Checkbox, {
      type: "checkbox",
      placeholder,
      defaultChecked: Boolean(value),
      ...commonProps,
      ...a11yProps
    }) : options && !radio ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Select, {
      defaultValue: value,
      ...commonProps,
      ...a11yProps,
      children: makeOptionComponents(makeSelectOption, options)
    }) : options && radio ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
      children: makeOptionComponents(makeRadioOption(commonProps, value), options)
    }) : multiline ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Multiline, {
      placeholder,
      defaultValue: value,
      ...commonProps,
      ...a11yProps
    }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
      type,
      placeholder,
      defaultValue: value,
      ...commonProps,
      ...a11yProps
    });
  };
}
function createField({
  register,
  fieldComponent: Field = "div",
  labelComponent: Label = "label",
  inputComponent: Input = "input",
  multilineComponent: Multiline = "textarea",
  selectComponent: Select = "select",
  radioComponent: Radio = "input",
  checkboxComponent: Checkbox = "input",
  checkboxWrapperComponent: CheckboxWrapper = "div",
  radioGroupComponent: RadioGroup = "fieldset",
  radioWrapperComponent: RadioWrapper = "div",
  fieldErrorsComponent: Errors = "div",
  errorComponent: Error2 = "div"
}) {
  return React2.forwardRef(
    ({
      fieldType = "string",
      shape,
      name,
      label,
      options,
      errors,
      dirty,
      type: typeProp,
      required = false,
      autoFocus = false,
      value: rawValue,
      multiline = false,
      radio = false,
      placeholder,
      hidden = false,
      children: childrenFn,
      ...props
    }, ref) => {
      const value = fieldType === "date" ? parseDate(rawValue) : rawValue;
      const field = {
        dirty,
        autoFocus,
        errors,
        fieldType,
        hidden,
        label,
        multiline,
        options,
        placeholder,
        radio,
        required,
        shape,
        value
      };
      const errorsChildren = (errors == null ? void 0 : errors.length) ? errors.map((error) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Error2, {
        children: error
      }, error)) : void 0;
      const style = hidden ? { display: "none" } : void 0;
      const type = typeProp ?? getInputType(fieldType, radio);
      const { ref: registerRef, ...registerProps } = register(String(name), {
        setValueAs: (value2) => coerceValue(value2, shape)
      });
      const labelId = `label-for-${name.toString()}`;
      const errorsId = `errors-for-${name.toString()}`;
      const a11yProps = {
        "aria-labelledby": labelId,
        "aria-invalid": Boolean(errors),
        "aria-describedby": errors ? errorsId : void 0,
        "aria-required": required
      };
      const SmartInput = React2.useMemo(
        () => createSmartInput({
          inputComponent: Input,
          multilineComponent: Multiline,
          selectComponent: Select,
          checkboxComponent: Checkbox,
          radioComponent: Radio,
          radioWrapperComponent: RadioWrapper,
          labelComponent: Label
        }),
        []
      );
      if (childrenFn) {
        const childrenDefinition = childrenFn({
          Label,
          SmartInput,
          Input,
          Multiline,
          Select,
          Checkbox,
          Radio,
          RadioGroup,
          RadioWrapper,
          CheckboxWrapper,
          Errors,
          Error: Error2,
          ref,
          name,
          type,
          ...field
        });
        const children = mapChildren(childrenDefinition, (child) => {
          const mergedRef = (instance) => {
            registerRef(instance);
            const { ref: childRef } = child;
            if (childRef) {
              childRef.current = instance;
            }
          };
          if (child.type === Label) {
            return React2.cloneElement(child, {
              id: labelId,
              htmlFor: String(name),
              children: label,
              ...child.props
            });
          } else if (child.type === SmartInput) {
            return React2.cloneElement(child, {
              fieldType,
              type,
              options,
              multiline,
              radio,
              placeholder,
              registerProps: { ...registerProps, ref: registerRef },
              autoFocus,
              value,
              a11yProps,
              ...child.props,
              ref: mergedRef
            });
          } else if (child.type === Input) {
            return React2.cloneElement(child, {
              id: String(name),
              type,
              ...registerProps,
              ...a11yProps,
              placeholder,
              autoFocus,
              defaultValue: value,
              ...child.props,
              ref: mergedRef
            });
          } else if (child.type === Multiline) {
            return React2.cloneElement(child, {
              id: String(name),
              ...registerProps,
              ...a11yProps,
              placeholder,
              autoFocus,
              defaultValue: value,
              ...child.props,
              ref: mergedRef
            });
          } else if (child.type === Select) {
            return React2.cloneElement(child, {
              id: String(name),
              ...registerProps,
              ...a11yProps,
              autoFocus,
              defaultValue: value,
              children: makeOptionComponents(makeSelectOption, options),
              ...child.props,
              ref: mergedRef
            });
          } else if (child.type === Checkbox && (child.type !== "input" || child.props.type === "checkbox")) {
            return React2.cloneElement(child, {
              id: String(name),
              type,
              autoFocus,
              ...registerProps,
              ...a11yProps,
              placeholder,
              defaultChecked: Boolean(value),
              ...child.props,
              ref: mergedRef
            });
          } else if (child.type === RadioGroup) {
            return React2.cloneElement(child, {
              ...a11yProps,
              ...child.props
            });
          } else if (child.type === Radio && (child.type !== "input" || child.props.type === "radio")) {
            return React2.cloneElement(child, {
              id: `${String(name)}-${child.props.value}`,
              type: "radio",
              autoFocus,
              ...registerProps,
              defaultChecked: value === child.props.value,
              ...child.props,
              ref: mergedRef
            });
          } else if (child.type === Errors) {
            if (!child.props.children && !(errors == null ? void 0 : errors.length))
              return null;
            if (child.props.children || !(errors == null ? void 0 : errors.length)) {
              return React2.cloneElement(child, {
                id: errorsId,
                role: "alert",
                ...child.props
              });
            }
            return React2.cloneElement(child, {
              id: errorsId,
              role: "alert",
              children: errorsChildren,
              ...child.props
            });
          } else {
            return child;
          }
        });
        const fixRadioLabels = (children2) => mapChildren(children2, (child) => {
          var _a;
          if (child.type === Label) {
            const parent = findParent(children2, child);
            if (parent && parent.type === RadioWrapper) {
              const radioChild = findElement(
                (_a = parent.props) == null ? void 0 : _a.children,
                (ch) => ch.type === Radio
              );
              if (radioChild) {
                return React2.cloneElement(child, {
                  htmlFor: radioChild.props.id
                });
              }
            }
          }
          return child;
        });
        return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FieldContext.Provider, {
          value: field,
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Field, {
            hidden,
            style,
            ...props,
            children: fixRadioLabels(children)
          })
        });
      }
      const smartInput = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SmartInput, {
        fieldType,
        type,
        options,
        multiline,
        radio,
        placeholder,
        registerProps: { ref: registerRef, ...registerProps },
        autoFocus,
        value,
        a11yProps
      });
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FieldContext.Provider, {
        value: field,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Field, {
          hidden,
          style,
          ...props,
          children: [
            fieldType === "boolean" ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CheckboxWrapper, {
              children: [
                smartInput,
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Label, {
                  id: labelId,
                  htmlFor: String(name),
                  children: label
                })
              ]
            }) : radio ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Label, {
                  id: labelId,
                  children: label
                }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(RadioGroup, {
                  ...a11yProps,
                  children: smartInput
                })
              ]
            }) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Label, {
                  id: labelId,
                  htmlFor: String(name),
                  children: label
                }),
                smartInput
              ]
            }),
            Boolean(errorsChildren) && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Errors, {
              role: "alert",
              id: errorsId,
              children: errorsChildren
            })
          ]
        })
      });
    }
  );
}

// src/defaultRenderField.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
function defaultRenderField({
  Field,
  name,
  ...props
}) {
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Field, {
    name,
    ...props
  }, String(name));
}

// src/inferLabel.ts
function startCase(str) {
  const matches = str.match(
    /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g
  ) ?? [""];
  return matches.map((x) => x.charAt(0).toUpperCase() + x.slice(1)).join(" ");
}
function inferLabel(fieldName) {
  return startCase(fieldName).replace(/Url/g, "URL");
}

// src/createForm.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
var fieldTypes = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBoolean: "boolean",
  ZodDate: "date",
  ZodEnum: "string"
};
function coerceToForm(value, shape) {
  const { typeName } = shape;
  if (typeName === "ZodBoolean") {
    return Boolean(value) ?? false;
  }
  if (typeName === "ZodDate") {
    return parseDate(value);
  }
  if (typeName === "ZodEnum" || typeName === "ZodString" || typeName === "ZodNumber") {
    return String(value ?? "");
  }
  return value ?? "";
}
function createForm({
  component: DefaultComponent,
  useNavigation,
  useSubmit,
  useActionData
}) {
  return function Form({
    component = DefaultComponent,
    fetcher,
    mode = "onSubmit",
    reValidateMode = "onChange",
    renderField = defaultRenderField,
    fieldComponent,
    globalErrorsComponent: Errors = "div",
    errorComponent: Error2 = "div",
    fieldErrorsComponent,
    labelComponent,
    inputComponent,
    multilineComponent,
    selectComponent,
    checkboxComponent,
    radioComponent,
    checkboxWrapperComponent,
    radioGroupComponent,
    radioWrapperComponent,
    buttonComponent: Button = "button",
    buttonLabel: rawButtonLabel = "OK",
    pendingButtonLabel = "OK",
    method = "post",
    schema,
    beforeChildren,
    onTransition,
    parseActionData,
    children: childrenFn,
    labels,
    placeholders,
    options,
    hiddenFields,
    multiline,
    radio,
    autoFocus: autoFocusProp,
    errors: errorsProp,
    values: valuesProp,
    ...props
  }) {
    const Component = (fetcher == null ? void 0 : fetcher.Form) ?? component;
    const navigationSubmit = useSubmit();
    const submit = (fetcher == null ? void 0 : fetcher.submit) ?? navigationSubmit;
    const navigationTransition = useNavigation();
    const transition = fetcher ?? navigationTransition;
    const navigationActionData = useActionData();
    const unparsedActionData = (fetcher == null ? void 0 : fetcher.data) ?? navigationActionData;
    const actionData = parseActionData && unparsedActionData ? parseActionData(unparsedActionData) : unparsedActionData;
    const actionErrors = actionData == null ? void 0 : actionData.errors;
    const actionValues = actionData == null ? void 0 : actionData.values;
    const errors = { ...errorsProp, ...actionErrors };
    const values = { ...valuesProp, ...actionValues };
    const schemaShape = objectFromSchema(schema).shape;
    const defaultValues = mapObject(schemaShape, (key, fieldShape) => {
      var _a;
      const shape = shapeInfo(fieldShape);
      const defaultValue = coerceToForm(
        values[key] ?? ((_a = shape == null ? void 0 : shape.getDefaultValue) == null ? void 0 : _a.call(shape)),
        shape
      );
      return [key, defaultValue];
    });
    const form = (0, import_react_hook_form.useForm)({
      resolver: (0, import_zod.zodResolver)(schema),
      mode,
      reValidateMode,
      defaultValues
    });
    const { formState, reset } = form;
    const { errors: formErrors, isValid } = formState;
    const onSubmit = (event) => {
      form.handleSubmit(() => submit(event.target))(event);
    };
    const formRef = React3.useRef(null);
    const doSubmit = () => {
      var _a;
      (_a = formRef.current) == null ? void 0 : _a.dispatchEvent(
        new Event("submit", { cancelable: true, bubbles: true })
      );
    };
    const Field = React3.useMemo(
      () => createField({
        register: form.register,
        fieldComponent,
        labelComponent,
        inputComponent,
        multilineComponent,
        selectComponent,
        checkboxComponent,
        radioComponent,
        checkboxWrapperComponent,
        radioGroupComponent,
        radioWrapperComponent,
        fieldErrorsComponent,
        errorComponent: Error2
      }),
      [
        fieldComponent,
        labelComponent,
        inputComponent,
        multilineComponent,
        selectComponent,
        checkboxComponent,
        radioComponent,
        checkboxWrapperComponent,
        radioGroupComponent,
        radioWrapperComponent,
        fieldErrorsComponent,
        Error2,
        form.register
      ]
    );
    const fieldErrors = (key) => {
      var _a;
      const message = (_a = formErrors[key]) == null ? void 0 : _a.message;
      return browser() ? message && [message] : errors && errors[key];
    };
    const firstErroredField = () => Object.keys(schemaShape).find((key) => {
      var _a;
      return (_a = fieldErrors(key)) == null ? void 0 : _a.length;
    });
    const makeField = (key) => {
      const shape = schemaShape[key];
      const { typeName, optional, nullable, enumValues } = shapeInfo(shape);
      const required = !(optional || nullable);
      const fieldOptions = (options == null ? void 0 : options[key]) || (enumValues == null ? void 0 : enumValues.map((value) => ({
        name: inferLabel(value),
        value
      })));
      const fieldOptionsPlusEmpty = () => fieldOptions && [{ name: "", value: "" }, ...fieldOptions ?? []];
      return {
        shape,
        fieldType: typeName ? fieldTypes[typeName] : "string",
        name: key,
        required,
        dirty: key in formState.dirtyFields,
        label: labels && labels[key] || inferLabel(String(key)),
        options: required ? fieldOptions : fieldOptionsPlusEmpty(),
        errors: fieldErrors(key),
        autoFocus: key === firstErroredField() || key === autoFocusProp,
        value: defaultValues[key],
        hidden: hiddenFields && Boolean(hiddenFields.find((item) => item === key)),
        multiline: multiline && Boolean(multiline.find((item) => item === key)),
        radio: radio && Boolean(radio.find((item) => item === key)),
        placeholder: placeholders && placeholders[key]
      };
    };
    const hiddenFieldsErrorsToGlobal = (globalErrors2 = []) => {
      const deepHiddenFieldsErrors = hiddenFields == null ? void 0 : hiddenFields.map((hiddenField) => {
        const hiddenFieldErrors = fieldErrors(hiddenField);
        if (hiddenFieldErrors instanceof Array) {
          const hiddenFieldLabel = labels && labels[hiddenField] || inferLabel(String(hiddenField));
          return hiddenFieldErrors.map(
            (error) => `${hiddenFieldLabel}: ${error}`
          );
        } else
          return [];
      });
      const hiddenFieldsErrors = (deepHiddenFieldsErrors == null ? void 0 : deepHiddenFieldsErrors.flat()) || [];
      const allGlobalErrors = [].concat(globalErrors2, hiddenFieldsErrors).filter((error) => typeof error === "string");
      return allGlobalErrors.length > 0 ? allGlobalErrors : void 0;
    };
    let globalErrors = hiddenFieldsErrorsToGlobal(errors == null ? void 0 : errors._global);
    const buttonLabel = transition.state === "submitting" ? pendingButtonLabel : rawButtonLabel;
    const [disabled, setDisabled] = React3.useState(false);
    const customChildren = mapChildren(
      childrenFn == null ? void 0 : childrenFn({
        Field,
        Errors,
        Error: Error2,
        Button,
        submit: doSubmit,
        ...form
      }),
      (child) => {
        if (child.type === Field) {
          const { name } = child.props;
          const field = makeField(name);
          const autoFocus = firstErroredField() ? field == null ? void 0 : field.autoFocus : child.props.autoFocus ?? (field == null ? void 0 : field.autoFocus);
          if (!child.props.children && field) {
            return renderField({
              Field,
              ...field,
              ...child.props,
              autoFocus
            });
          }
          return React3.cloneElement(child, {
            shape: field == null ? void 0 : field.shape,
            fieldType: field == null ? void 0 : field.fieldType,
            label: field == null ? void 0 : field.label,
            placeholder: field == null ? void 0 : field.placeholder,
            required: field == null ? void 0 : field.required,
            options: field == null ? void 0 : field.options,
            value: field == null ? void 0 : field.value,
            errors: field == null ? void 0 : field.errors,
            hidden: field == null ? void 0 : field.hidden,
            multiline: field == null ? void 0 : field.multiline,
            ...child.props,
            autoFocus
          });
        } else if (child.type === Errors) {
          if (!child.props.children && !(globalErrors == null ? void 0 : globalErrors.length))
            return null;
          if (child.props.children || !(globalErrors == null ? void 0 : globalErrors.length)) {
            return React3.cloneElement(child, {
              role: "alert",
              ...child.props
            });
          }
          return React3.cloneElement(child, {
            role: "alert",
            children: globalErrors.map((error) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Error2, {
              children: error
            }, error)),
            ...child.props
          });
        } else if (child.type === Button) {
          return React3.cloneElement(child, {
            disabled,
            children: buttonLabel,
            ...child.props
          });
        } else {
          return child;
        }
      }
    );
    const defaultChildren = () => /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, {
      children: [
        Object.keys(schemaShape).map(makeField).map((field) => renderField({ Field, ...field })),
        (globalErrors == null ? void 0 : globalErrors.length) && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Errors, {
          role: "alert",
          children: globalErrors.map((error) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Error2, {
            children: error
          }, error))
        }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Button, {
          disabled,
          children: buttonLabel
        })
      ]
    });
    React3.useEffect(() => {
      const shouldDisable = mode === "onChange" || mode === "all" ? transition.state === "submitting" || !isValid : transition.state === "submitting";
      setDisabled(shouldDisable);
    }, [transition.state, formState, mode, isValid]);
    React3.useEffect(() => {
      const newDefaults = Object.fromEntries(
        reduceElements(customChildren, [], (prev, child) => {
          if (child.type === Field) {
            const { name, value } = child.props;
            prev.push([name, value]);
          }
          return prev;
        })
      );
      reset({ ...defaultValues, ...newDefaults });
    }, []);
    React3.useEffect(() => {
      Object.keys(errors).forEach((key) => {
        form.setError(key, {
          type: "custom",
          message: errors[key].join(", ")
        });
      });
      if (firstErroredField()) {
        try {
          form.setFocus(firstErroredField());
        } catch {
        }
      }
    }, [errorsProp, unparsedActionData]);
    React3.useEffect(() => {
      onTransition && onTransition(form);
    }, [transition.state]);
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react_hook_form.FormProvider, {
      ...form,
      children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(Component, {
        ref: formRef,
        method,
        onSubmit,
        ...props,
        children: [
          beforeChildren,
          customChildren ?? defaultChildren()
        ]
      })
    });
  };
}

// src/mutations.ts
var import_domain_functions = require("domain-functions");
async function getFormValues(request, schema) {
  const shape = objectFromSchema(schema).shape;
  const input = await (0, import_domain_functions.inputFromForm)(request);
  let values = {};
  for (const key in shape) {
    const value = input[key];
    values[key] = coerceValue(value, shape[key]);
  }
  return values;
}
async function performMutation({
  request,
  schema,
  mutation,
  environment,
  transformValues = (values) => values
}) {
  const values = await getFormValues(request, schema);
  const result = await mutation(transformValues(values), environment);
  if (result.success) {
    return { success: true, data: result.data };
  } else {
    return {
      success: false,
      errors: {
        ...(0, import_domain_functions.errorMessagesForSchema)(result.inputErrors, schema),
        _global: result.errors.length || result.environmentErrors.length ? [...result.errors, ...result.environmentErrors].map(
          (error) => error.message
        ) : void 0
      },
      values
    };
  }
}
function createFormAction({
  redirect,
  json
}) {
  async function formAction({
    request,
    schema,
    mutation,
    environment,
    transformValues,
    beforeAction,
    beforeSuccess,
    successPath
  }) {
    if (beforeAction) {
      const beforeActionResponse = await beforeAction(request);
      if (beforeActionResponse)
        return beforeActionResponse;
    }
    const result = await performMutation({
      request,
      schema,
      mutation,
      environment,
      transformValues
    });
    if (result.success) {
      if (beforeSuccess) {
        const beforeSuccessResponse = await beforeSuccess(request);
        if (beforeSuccessResponse)
          return beforeSuccessResponse;
      }
      const path = typeof successPath === "function" ? successPath(result.data) : successPath;
      return path ? redirect(path) : json(result.data);
    } else {
      return json({ errors: result.errors, values: result.values });
    }
  }
  return formAction;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createForm,
  createFormAction,
  performMutation,
  useField
});
